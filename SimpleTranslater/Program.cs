using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Strings;
using Mutagen.Bethesda.Plugins;
using Noggog;
using System.Collections.Immutable;
using System.Text;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Plugins.Binary.Translations;
using Mutagen.Bethesda.Plugins.Cache.Internals.Implementations;
using Mutagen.Bethesda.Plugins.Records;

namespace SimpleTranslator;

public class Program
{
    static Program()
    {
        Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
        win1252Encoding = Encoding.GetEncoding(1252);
    }
    static Lazy<Settings> settings = null!;
    static Settings Settings => settings!.Value;
    static Encoding UnicodeEncoding = Encoding.Unicode;
    static Encoding utf8Encoding = Encoding.UTF8;
    static Encoding win1252Encoding = null!;

    public static async Task<int> Main(string[] args)
    {
        return await SynthesisPipeline.Instance
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
            .SetAutogeneratedSettings("Settings", "settings.json", out settings)
            .SetTypicalOpen(GameRelease.SkyrimSE, "SimpleTranslator.esp")
            .Run(args);
    }

    public static string EncodingConvert(string str)
    {
        var bytes = UnicodeEncoding.GetBytes(str);
        Console.WriteLine(bytes);
        return win1252Encoding.GetString(bytes);
    }

    public static void Patch<TCache, TTarget>(
        ImmutableLoadOrderLinkCache<ISkyrimMod, ISkyrimModGetter> cache,
        IEnumerable<TCache> sourceModEntities,
        IGroup<TTarget> patchedModsEntities,
        string keyWord,
        Action<TTarget, TCache>? action = null)
        where TCache : class, IMajorRecordGetter, ITranslatedNamedGetter
        where TTarget : class, IMajorRecordInternal, ITranslatedNamed, TCache
    {
        int i = 0;
        foreach (var translating in Settings.PatchAllEntity ? sourceModEntities : patchedModsEntities)
        {
            var target = patchedModsEntities.GetOrAddAsOverride(translating);
            var result = cache.TryResolve<TCache>(translating.FormKey, out var cached, Settings.ResolveFromOrigin ? ResolveTarget.Origin : ResolveTarget.Winner);
            if (Settings.Verbose)
            {
                Console.Write($"[{keyWord}] EditorId:[{translating.EditorID}], FormId:[{translating.FormKey.ID}] ");
            }
            if (!result)
            {
                Console.WriteLine($"Resolving {translating.FormKey} from {(Settings.ResolveFromOrigin ? "Origin" : "Winner")} Failed");
            }
            if (cached?.Name?.String != null && translating.Name?.String != null && cached.Name.String.Equals(translating.Name.String))
            {
                if (Settings.Verbose)
                {
                    Console.WriteLine($"{cached.Name.String} Skipped");
                }
                continue;
            }
            if (cached?.Name?.String != null && target?.Name?.String != null)
            {
                var translatedName = Settings.CustomDictionary.ContainsKey(cached.Name.String)
                    ? Settings.CustomDictionary[cached.Name.String] : cached.Name.String;
                if (Settings.Verbose && string.Equals(target.Name.String, translatedName))
                {
                    Console.WriteLine($"{cached.Name.String} Skipped");
                    continue;
                }
                if (Settings.Verbose)
                {
                    Console.WriteLine($"{translating.Name} ==> {translatedName}");
                }
                target.Name = translatedName;
                action?.Invoke(target, cached);
                i++;
            }
            else if (Settings.Verbose)
            {
                Console.WriteLine("Something is null");
            }
        }
        Console.WriteLine($"Patched {i}");
    }

    public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        var cache = state.LoadOrder.ListedOrder
            .SkipLast(1)
            .Where(x =>
            {
                if (x.ModKey.Equals(state.PatchMod.ModKey))
                {
                    return false;
                }
                if (Settings.IgnorePatchMods && x.ModKey.Name.ContainsInsensitive("Patch") && !Settings.IncludedPatchMods.Contains(x.ModKey))
                {
                    return false;
                }
                return Settings.WhiteListMode ? Settings.WhiteList.Contains(x.ModKey) : !Settings.BlackList.Contains(x.ModKey);
            })
            .ToImmutableLinkCache();
        if (Settings.Verbose)
        {
            Console.WriteLine();
            Console.WriteLine("===========================================");
            Console.WriteLine("========== Caches Priority Order ==========");
            Console.WriteLine("===========================================");
            Console.WriteLine($"Reference name from lowest priority: {Settings.ResolveFromOrigin}");
            cache.PriorityOrder.ForEach(x => Console.WriteLine($"{x.ModKey}"));
        }

        if (Settings.Npc)
        {
            Console.WriteLine();
            Console.WriteLine("==================================");
            Console.WriteLine("========== Patching NPC ==========");
            Console.WriteLine("==================================");
            Patch(cache, state.LoadOrder.PriorityOrder.Npc().WinningOverrides(), state.PatchMod.Npcs, "NPC", (target, cache) =>
            {
                if (cache.ShortName != null)
                {
                    target.ShortName = cache.ShortName.String;
                }
            });
        }

        if (Settings.Weapon)
        {
            Console.WriteLine();
            Console.WriteLine("=====================================");
            Console.WriteLine("========== Patching Weapon ==========");
            Console.WriteLine("=====================================");
            Patch(cache, state.LoadOrder.PriorityOrder.Weapon().WinningOverrides(), state.PatchMod.Weapons, "Weapon");
        }

        if (Settings.Armor)
        {
            Console.WriteLine();
            Console.WriteLine("====================================");
            Console.WriteLine("========== Patching Armor ==========");
            Console.WriteLine("====================================");
            Patch(cache, state.LoadOrder.PriorityOrder.Armor().WinningOverrides(), state.PatchMod.Armors, "Armor", (target, cache) =>
            {
                if (cache.Description != null)
                {
                    target.Description = cache.Description.String;
                }
            });
        }

        if (Settings.Item)
        {
            Console.WriteLine();
            Console.WriteLine("===================================");
            Console.WriteLine("========== Patching Item ==========");
            Console.WriteLine("===================================");
            Patch(cache, state.LoadOrder.PriorityOrder.MiscItem().WinningOverrides(), state.PatchMod.MiscItems, "Item");
        }

        if (Settings.WorldSpace)
        {
            Console.WriteLine();
            Console.WriteLine("=========================================");
            Console.WriteLine("========== Patching WorldSpace ==========");
            Console.WriteLine("=========================================");
            Patch(cache, state.LoadOrder.PriorityOrder.Worldspace().WinningOverrides(), state.PatchMod.Worldspaces, "WorldSpace");
        }

        if (Settings.Perk)
        {
            Console.WriteLine();
            Console.WriteLine("===================================");
            Console.WriteLine("========== Patching Perk ==========");
            Console.WriteLine("===================================");
            Patch(cache, state.LoadOrder.PriorityOrder.Perk().WinningOverrides(), state.PatchMod.Perks, "Perk");
        }
    }
}
